/*
 * partial_pcd_source.h
 *
 *  Created on: Jul 3, 2012
 *      Author: aitor
 */

#ifndef FAAT_PCL_PARTIAL_PCD_SOURCE_H_
#define FAAT_PCL_PARTIAL_PCD_SOURCE_H_

#include "source.h"
#include <pcl/visualization/pcl_visualizer.h>
#include <vtkPlatonicSolidSource.h>
#include <vtkLoopSubdivisionFilter.h>
#include <vtkTriangle.h>
#include <vtkTransform.h>
#include <vtkVisibleCellSelector.h>
#include <vtkSelection.h>
#include <vtkCellArray.h>
#include <vtkTransformFilter.h>
#include "pcl/recognition/hv/occlusion_reasoning.h"
#include "pcl/recognition/impl/hv/occlusion_reasoning.hpp"
#include "faat_3d_rec_framework_defines.h"

namespace faat_pcl
{
  namespace rec_3d_framework
  {

    /**
     * \brief Data source class to generate partial views from a "full" 3D model obtained
     * by fusing different views of the sensor. The partial views are generated by placing
     * the camera around the object (camera positions can be constrained) to avoid using viewpoints
     * where the model has not been trained.
     * \author Aitor Aldoma
     */

    template<typename Full3DPointT = pcl::PointXYZRGBNormal, typename PointInT = pcl::PointXYZRGB, typename OutModelPointT = pcl::PointXYZRGB>
      class PartialPCDSource : public Source<PointInT>
      {

        typedef Source<PointInT> SourceT;
        typedef Model<OutModelPointT> ModelT;
        typedef boost::shared_ptr<ModelT> ModelTPtr;

        using SourceT::path_;
        using SourceT::models_;
        using SourceT::createTrainingDir;
        using SourceT::getModelsInDirectory;
        using SourceT::model_scale_;
        using SourceT::load_views_;
        using SourceT::getViewsFilenames;
        using SourceT::load_into_memory_;

        bool use_vertices_;
        int tes_level_;
        int resolution_;
        float radius_sphere_;
        float dot_normal_;
        bool gen_organized_;
        int cx_size, cy_size;
        float f_;
        bool gen_inplane_rotations_;
        float angle_incr_inplane_;

        //std::function<bool (const Eigen::Vector3f &)> campos_constraints_func_;
        boost::function<bool
        (const Eigen::Vector3f &)> campos_constraints_func_;

        void
        loadInMemorySpecificModel(std::string & dir, ModelT & model);

        void
        loadOrGenerate (std::string & dir, std::string & model_path, ModelT & model);

        void assembleModelFromViewsAndPoses(ModelT & model,
                                       std::vector<Eigen::Matrix4f, Eigen::aligned_allocator<Eigen::Matrix4f> > & poses,
                                       std::vector<pcl::PointIndices> & indices,
                                       typename pcl::PointCloud<PointInT>::Ptr &model_cloud);
      public:

        PartialPCDSource ()
        {
          use_vertices_ = false;
          tes_level_ = 1;
          dot_normal_ = 0.1;
          load_into_memory_ = true;
          gen_organized_ = false;
          cx_size = cy_size = 150.f;
          gen_inplane_rotations_ = false;
          f_ = 525.f;
        }

        void genInPlaneRotations(bool b, float angle = 0.f)
        {
          gen_inplane_rotations_ = b;
          angle_incr_inplane_ = angle;
        }

        void
        loadInMemorySpecificModelAndView(std::string & dir, ModelT & model, int view_id);

        void
        setDotNormal (float f)
        {
          dot_normal_ = f;
        }

        void
        setCamPosConstraints (boost::function<bool
        (const Eigen::Vector3f &)> & bb)
        {
          campos_constraints_func_ = bb;
        }

        void
        setTesselationLevel (int lev)
        {
          tes_level_ = lev;
        }

        void
        setRadiusSphere (float r)
        {
          radius_sphere_ = r;
        }

        void
        setUseVertices (bool b)
        {
          use_vertices_ = b;
        }

        void
        setGenOrganized(bool b)
        {
          gen_organized_ = b;
        }

        void setWindowSizeAndFocalLength(int cx, int cy, float f)
        {
          cx_size = cx;
          cy_size = cy;
          f_ = f;
        }

        bool
        isleafDirectory (bf::path & path)
        {
          bf::directory_iterator end_itr;
          bool no_dirs_inside = true;
          for (bf::directory_iterator itr (path); itr != end_itr; ++itr)
          {
            if (bf::is_directory (*itr))
            {
              no_dirs_inside = false;
            }
          }

          return no_dirs_inside;
        }

        void
        getFilesInDirectory (bf::path & dir, std::string & rel_path_so_far, std::vector<std::string> & relative_paths, std::string & ext)
        {
          bf::directory_iterator end_itr;
          for (bf::directory_iterator itr (dir); itr != end_itr; ++itr)
          {
            //check if its a directory, then ignore
            if (bf::is_directory (*itr))
            {

            }
            else
            {
              std::vector < std::string > strs;
#if BOOST_FILESYSTEM_VERSION == 3
              std::string file = (itr->path ().filename ()).string();
#else
              std::string file = (itr->path ()).filename ();
#endif

              boost::split (strs, file, boost::is_any_of ("."));
              std::string extension = strs[strs.size () - 1];

              if (extension.compare (ext) == 0)
              {
#if BOOST_FILESYSTEM_VERSION == 3
                std::string path = rel_path_so_far + (itr->path ().filename ()).string();
#else
                std::string path = rel_path_so_far + (itr->path ()).filename ();
#endif

                relative_paths.push_back (path);
              }
            }
          }
        }

        /**
         * \brief Creates the model representation of the training set, generating views if needed
         */
        void
        generate (std::string & training_dir)
        {

          //create training dir fs if not existent
          createTrainingDir (training_dir);

          //get models in directory
          std::vector < std::string > files;
          std::string start = "";
          bf::path dir = path_;
          std::string ext = "pcd";
          getFilesInDirectory (dir, start, files, ext);

          models_.reset (new std::vector<ModelTPtr>);

          for (size_t i = 0; i < files.size (); i++)
          {
            ModelTPtr m(new ModelT());

            std::vector < std::string > strs;
            boost::split (strs, files[i], boost::is_any_of ("/\\"));
            std::string name = strs[strs.size () - 1];

            if (strs.size () == 1)
            {
              m->id_ = strs[0];
              m->class_ = strs[strs.size () - 1];
            }
            else
            {
              std::stringstream ss;
              for (int i = 0; i < (static_cast<int> (strs.size ()) - 1); i++)
              {
                ss << strs[i];
                if (i != (static_cast<int> (strs.size ()) - 1))
                  ss << "/";
              }

              m->class_ = ss.str ();
              m->id_ = strs[strs.size () - 1];
            }

            std::cout << m->class_ << " . " << m->id_ << std::endl;
            //check which of them have been trained using training_dir and the model_id_
            //load views, poses and self-occlusions for those that exist
            //generate otherwise

            std::stringstream model_path;
            model_path << path_ << "/" << files[i];
            std::string path_model = model_path.str ();
            loadOrGenerate (training_dir, path_model, *m);
            models_->push_back (m);
            std::cout << files[i] << std::endl;
          }

          std::cout << "Total number of models:" << models_->size () << std::endl;
        }

      };
  }
}

#endif /* PARTIAL_PCD_SOURCE_H_ */
